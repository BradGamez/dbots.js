<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Interface/Poster.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Interface/Poster.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Constants = require('../Utils/Constants');
const EnsurePromise = require('../Utils/EnsurePromise');
const FormatRequest = require('../Utils/FormatRequest');

/**
 * A class that posts server count to listing site(s).
 * @constructor
 * @param {PosterOptions} options The options needed to construct the poster.
 */
class Poster {
  constructor(options) {
    if (!options || typeof options !== 'object') throw new Error("An object is required a parameter to construct a poster.");
    this.client = options.client;
    if (typeof options.useSharding !== 'boolean') options.useSharding = true;
    if (!this.client &amp;&amp; !options.clientID) throw new Error("clientID must be defined when client is non-existant.");
    if (this.client &amp;&amp; !options.clientID) Object.assign(options, Constants.AutoValueFunctions[options.clientLibrary](options.client));
    if (!options.useSharding) options.shard = undefined;
    this.options = options;
    this.handlers = {};
    for (let event of Constants.SupportedEvents) this.handlers[event] = [];
  }

  /**
    * Retrieves the current server count of the client/shard
    * @returns {Promise&lt;Number>} Amount of servers the client/shard is in
    */
  getServerCount() {
    if (!this.client) throw new Error('Cannot retrieve server count from non-existant client');
    if (this.options.serverCount) return EnsurePromise(this.options.serverCount);
    if (!this.options.serverCount &amp;&amp; !this.options.clientLibrary) throw new Error('Cannot retrieve server count from unknown client');
    return EnsurePromise(Constants.ServerCountFunctions[this.options.clientLibrary], this.client);
  }

  /**
    * Retrieves the current user count of the client/shard
    * @returns {Promise&lt;Number>} Amount of users the client/shard is connected with
   */
  getUserCount() {
    if (!this.client) throw new Error('Cannot retrieve user count from non-existant client');
    if (this.options.userCount) return EnsurePromise(this.options.userCount);
    if (!this.options.userCount &amp;&amp; !this.options.clientLibrary) throw new Error('Cannot retrieve user count from unknown client');
    return EnsurePromise(Constants.UserCountFunctions[this.options.clientLibrary], this.client);
  }

  /**
   * Retrieves the current voice connection count of the client/shard
   * @returns {Promise&lt;Number>} Number of active voice connections
   */
  getVoiceConnections() {
    if (!this.client) throw new Error('Cannot retrieve voice connection count from non-existant client');
    if (this.options.voiceConnections) return EnsurePromise(this.options.voiceConnections);
    if (!this.options.voiceConnections &amp;&amp; !this.options.clientLibrary) throw new Error('Cannot retrieve voice connection count from unknown client');
    return EnsurePromise(Constants.VoiceConnectionsFunctions[this.options.clientLibrary], this.client);
  }

  /**
    * Creates an interval that posts to all services
    * @param {number} interval The time (in ms) to reach to post to all {@link Service}s again.
    * @returns {Interval} The interval that is responsible for posting
    */
  startInterval(interval = 1800000) {
    clearTimeout(this._interval);
    this._interval = setInterval(() => this.post().then(result => {
      this.runHandlers('autopost', result);
      return result;
    }).catch(error => this.runHandlers('autopostfail', error)), interval);
    return this._interval;
  }

  /**
    * Destroys the current interval
    */
  stopInterval() {
    if (this._interval) clearTimeout(this._interval);
  }

  /**
    * Posts the current clients server count to a service
    * @see DBotsPoster#postManual
    */
  post(service) {
    let _this = this;
    return new Promise((resolve, reject) => {
      return Promise.all([_this.getServerCount(), _this.getUserCount(), _this.getVoiceConnections()])
        .then(([serverCount, userCount, voiceConnections]) => {
          _this.postManual(serverCount, service, userCount, voiceConnections)
            .then(resolve).catch(reject);
        }).catch(reject);
    });
  }

  /**
    * Manually posts a server count to a service
    * @param {Number} serverCount The server count to post to the service
    * @param {Service} service The service to post to
    * @param {Number} [userCount] The server count to post to the service
    * @param {Number} [voiceConnections] The voice connection count to post to the service
    * @returns {Promise&lt;Object|Array&lt;Object>>} The result(s) of the post
    */
  postManual(serverCount, service = 'all', userCount = undefined, voiceConnections = undefined) {
    if (!this.options.apiKeys &amp;&amp; !this.options.post) throw new Error('NO_API_KEYS');
    if (!this.options.apiKeys || service === 'custom') return EnsurePromise(this.options.post, this.options.clientID, serverCount, this.options.shard);
    if (!service || service === 'all') return Promise.all(Object.keys(this.options.apiKeys).map(k => this.postManual(serverCount, k)));
    if (!Constants.AvailableServices.includes(service)) throw new Error('INVALID_SERVICE', service);
    if (!Object.keys(this.options.apiKeys).includes(service)) throw new Error('SERVICE_WITH_NO_KEY', service);
    return new Promise((resolve, reject) => {
      FormatRequest(
        Constants.PostFormat[service](this.options.apiKeys[service],
          this.options.clientID,
          serverCount,
          this.options.shard,
          userCount,
          voiceConnections
      )).then(result => {
        this.runHandlers('post', result);
        resolve(result);
      }).catch(error => {
        this.runHandlers('postfail', error);
        reject(error);
      });
    });
  }

  /**
   * Adds an handler for an event
   * @param {CustomEvent} event The name of the event to add the handler to
   * @param {PromiseResolvable} handler The function that is run with the event
   * @returns {Array&lt;PromiseResolvable>} The array of handlers currently set for that event
   */
  addHandler(event, handler) {
    if (!Constants.SupportedEvents.includes(event)) throw new Error('Can\'t add handler for an unsupported event.');
    if (!(handler instanceof Function || handler instanceof Promise)) throw new Error('Given handler is not a PromiseResolvable.');
    return this.handlers[event].push(handler);
  }

  /**
   * Removes an handler for an event
   * @param {CustomEvent} event The name of the event to remove the handler from
   * @param {PromiseResolvable} handler The function that is run with the event
   * @returns {Array&lt;PromiseResolvable>} The array of handlers currently set for that event
   */
  removeHandler(event, handler) {
    if (!Constants.SupportedEvents.includes(event)) throw new Error('Can\'t remove handler for an unsupported event.');
    if (!(handler instanceof Function || handler instanceof Promise)) throw new Error('Given handler is not a PromiseResolvable.');
    let index = this.handlers[event].indexOf(handler);
    if (index >= 0) this.handlers[event].splice(index, 1);
    return this.handlers[event];
  }

  /**
   * Manually triggers an event with custom arguments
   * @param {CustomEvent} event The name of the event to run the handlers for
   * @param  {...any} args The arguments to pass to the handlers
   */
  runHandlers(event, ...args) {
    if (!Constants.SupportedEvents.includes(event)) throw new Error('Can\'t remove handler for an unsupported event.');
    for (let handler of this.handlers[event]) EnsurePromise(handler(...args));
  }
}

module.exports = Poster;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BotListSpace.html">BotListSpace</a></li><li><a href="BotsForDiscord.html">BotsForDiscord</a></li><li><a href="BotsOnDiscord.html">BotsOnDiscord</a></li><li><a href="DiscordAppsDev.html">DiscordAppsDev</a></li><li><a href="DiscordBoats.html">DiscordBoats</a></li><li><a href="DiscordBotList.html">DiscordBotList</a></li><li><a href="DiscordBotsGG.html">DiscordBotsGG</a></li><li><a href="DiscordBotWorld.html">DiscordBotWorld</a></li><li><a href="DivineDiscordBots.html">DivineDiscordBots</a></li><li><a href="GlennBotList.html">GlennBotList</a></li><li><a href="Poster.html">Poster</a></li><li><a href="ServiceBase.html">ServiceBase</a></li><li><a href="TopGG.html">TopGG</a></li></ul><h3>Events</h3><ul><li><a href="Poster.html#event:autopost">autopost</a></li><li><a href="Poster.html#event:autopostfail">autopostfail</a></li><li><a href="Poster.html#event:post">post</a></li><li><a href="Poster.html#event:postfail">postfail</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sun Jan 26 2020 17:04:18 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
